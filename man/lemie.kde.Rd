% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lemie.r
\name{lemie.kde}
\alias{lemie.kde}
\title{Monte Carlo estimate of posterior density}
\usage{
lemie.kde(
  x,
  theta,
  wn,
  bw,
  type = 2,
  Hvec = NULL,
  log. = FALSE,
  mem.limit = 1024^3
)
}
\arguments{
\item{x}{a vector of values for which the density estimate is to be computed.}

\item{theta}{a list of matrices, each containing samples of model parameters 
from partial posterior distributions. Each matrix should have the same 
number of columns, which correspond to model parameters (including 
components of parameter vectors). Each list element corresponds to a single 
partial posterior.}

\item{wn}{a list of matrices (for \code{type = 1} or \code{type = 2}) or a 
matrix (\code{type = 3}), each containing normalised weights, one for each 
sample in \code{theta} and obtained using the \code{\link{lemie.weights}} 
function.}

\item{bw}{the smoothing bandwidth to be used. The kernels are scaled such 
that this is the standard deviation of the (Gaussian) smoothing kernel.}

\item{type}{an integer, either 0, 1, 2 or 3, specifying the weighting type 
used. Types 1, 2 and 3 refer to the LEMIE weighting algorithms (see 
\code{lemie.weights}). Type 0 can be used to use uniform weights, which 
allows one to supply samples from another algorithm; in this case, \code{wn} 
is not required.}

\item{Hvec}{an optional vector specifying the number of samples taken from 
each partial posterior.}

\item{log.}{logical. If \code{TRUE}, density estimates are returned on the 
(natural) log scale.}

\item{mem.limit}{a positive value specifying the memory permitted for large 
arrays, in bytes. The function features a computational step that can 
consume a lot of memory. Increase this for a speed up or decrease it if 
memory is constrained.}
}
\value{
A vector the same length as \code{x} of density estimates.
}
\description{
Compute a KDE estimate of the posterior density evaluated at a number of 
values of a univariate random variable. The posterior is estimated with a 
Monte Carlo sample weighted by the LEMIE type 1 or type 2 importance weights.
}
\details{
The output of this function is the same as \code{lemie.mean} with a 
\code{FUN} argument being a Gaussian kernel function, evaluated over a range 
of values. This function is optimised to perform this without looping over 
target values.
}
\seealso{
\code{lemie.mkde}, \code{lemie.mean}, \code{lemie.weights}
}
